
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>nltk.chunk package &#8212; NLTK 3.6 documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/agogo.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="nltk.classify package" href="nltk.classify.html" />
    <link rel="prev" title="nltk.chat package" href="nltk.chat.html" /> 
  </head><body>
    <div class="header-wrapper" role="banner">
      <div class="header">
        <div class="headertitle"><a
          href="../index.html">NLTK 3.6 documentation</a></div>
        <div class="rel" role="navigation" aria-label="related navigation">
          <a href="nltk.chat.html" title="nltk.chat package"
             accesskey="P">previous</a> |
          <a href="nltk.classify.html" title="nltk.classify package"
             accesskey="N">next</a> |
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a>
        </div>
       </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
        <div class="document">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="nltk-chunk-package">
<h1>nltk.chunk package<a class="headerlink" href="#nltk-chunk-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-nltk.chunk.api">
<span id="nltk-chunk-api-module"></span><h2>nltk.chunk.api module<a class="headerlink" href="#module-nltk.chunk.api" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="nltk.chunk.api.ChunkParserI">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">nltk.chunk.api.</span></code><code class="sig-name descname"><span class="pre">ChunkParserI</span></code><a class="reference internal" href="../_modules/nltk/chunk/api.html#ChunkParserI"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.api.ChunkParserI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="nltk.parse.html#nltk.parse.api.ParserI" title="nltk.parse.api.ParserI"><code class="xref py py-class docutils literal notranslate"><span class="pre">nltk.parse.api.ParserI</span></code></a></p>
<p>A processing interface for identifying non-overlapping groups in
unrestricted text.  Typically, chunk parsers are used to find base
syntactic constituents, such as base noun phrases.  Unlike
<code class="docutils literal notranslate"><span class="pre">ParserI</span></code>, <code class="docutils literal notranslate"><span class="pre">ChunkParserI</span></code> guarantees that the <code class="docutils literal notranslate"><span class="pre">parse()</span></code> method
will always generate a parse.</p>
<dl class="py method">
<dt id="nltk.chunk.api.ChunkParserI.evaluate">
<code class="sig-name descname"><span class="pre">evaluate</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gold</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/api.html#ChunkParserI.evaluate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.api.ChunkParserI.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Score the accuracy of the chunker against the gold standard.
Remove the chunking the gold standard text, rechunk it using
the chunker, and return a <code class="docutils literal notranslate"><span class="pre">ChunkScore</span></code> object
reflecting the performance of this chunk peraser.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>gold</strong> (<em>list</em><em>(</em><a class="reference internal" href="nltk.html#nltk.tree.Tree" title="nltk.tree.Tree"><em>Tree</em></a><em>)</em>) – The list of chunked sentences to score the chunker on.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#nltk.chunk.util.ChunkScore" title="nltk.chunk.util.ChunkScore">ChunkScore</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltk.chunk.api.ChunkParserI.parse">
<code class="sig-name descname"><span class="pre">parse</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tokens</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/api.html#ChunkParserI.parse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.api.ChunkParserI.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the best chunk structure for the given tokens
and return a tree.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>tokens</strong> (<em>list</em><em>(</em><em>tuple</em><em>)</em>) – The list of (word, tag) tokens to be chunked.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="nltk.html#nltk.tree.Tree" title="nltk.tree.Tree">Tree</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-nltk.chunk.named_entity">
<span id="nltk-chunk-named-entity-module"></span><h2>nltk.chunk.named_entity module<a class="headerlink" href="#module-nltk.chunk.named_entity" title="Permalink to this headline">¶</a></h2>
<p>Named entity chunker</p>
<dl class="py class">
<dt id="nltk.chunk.named_entity.NEChunkParser">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">nltk.chunk.named_entity.</span></code><code class="sig-name descname"><span class="pre">NEChunkParser</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">train</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/named_entity.html#NEChunkParser"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.named_entity.NEChunkParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.api.ChunkParserI" title="nltk.chunk.api.ChunkParserI"><code class="xref py py-class docutils literal notranslate"><span class="pre">nltk.chunk.api.ChunkParserI</span></code></a></p>
<p>Expected input: list of pos-tagged words</p>
<dl class="py method">
<dt id="nltk.chunk.named_entity.NEChunkParser.parse">
<code class="sig-name descname"><span class="pre">parse</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tokens</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/named_entity.html#NEChunkParser.parse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.named_entity.NEChunkParser.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Each token should be a pos-tagged word</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nltk.chunk.named_entity.NEChunkParserTagger">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">nltk.chunk.named_entity.</span></code><code class="sig-name descname"><span class="pre">NEChunkParserTagger</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">train</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/named_entity.html#NEChunkParserTagger"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.named_entity.NEChunkParserTagger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="nltk.tag.html#nltk.tag.sequential.ClassifierBasedTagger" title="nltk.tag.sequential.ClassifierBasedTagger"><code class="xref py py-class docutils literal notranslate"><span class="pre">nltk.tag.sequential.ClassifierBasedTagger</span></code></a></p>
<p>The IOB tagger used by the chunk parser.</p>
</dd></dl>

<dl class="py function">
<dt id="nltk.chunk.named_entity.build_model">
<code class="sig-prename descclassname"><span class="pre">nltk.chunk.named_entity.</span></code><code class="sig-name descname"><span class="pre">build_model</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'binary'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/named_entity.html#build_model"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.named_entity.build_model" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="nltk.chunk.named_entity.cmp_chunks">
<code class="sig-prename descclassname"><span class="pre">nltk.chunk.named_entity.</span></code><code class="sig-name descname"><span class="pre">cmp_chunks</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">correct</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">guessed</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/named_entity.html#cmp_chunks"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.named_entity.cmp_chunks" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="nltk.chunk.named_entity.load_ace_data">
<code class="sig-prename descclassname"><span class="pre">nltk.chunk.named_entity.</span></code><code class="sig-name descname"><span class="pre">load_ace_data</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">roots</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'binary'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">skip_bnews</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/named_entity.html#load_ace_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.named_entity.load_ace_data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="nltk.chunk.named_entity.load_ace_file">
<code class="sig-prename descclassname"><span class="pre">nltk.chunk.named_entity.</span></code><code class="sig-name descname"><span class="pre">load_ace_file</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">textfile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmt</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/named_entity.html#load_ace_file"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.named_entity.load_ace_file" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="nltk.chunk.named_entity.postag_tree">
<code class="sig-prename descclassname"><span class="pre">nltk.chunk.named_entity.</span></code><code class="sig-name descname"><span class="pre">postag_tree</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tree</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/named_entity.html#postag_tree"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.named_entity.postag_tree" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="nltk.chunk.named_entity.shape">
<code class="sig-prename descclassname"><span class="pre">nltk.chunk.named_entity.</span></code><code class="sig-name descname"><span class="pre">shape</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">word</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/named_entity.html#shape"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.named_entity.shape" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="nltk.chunk.named_entity.simplify_pos">
<code class="sig-prename descclassname"><span class="pre">nltk.chunk.named_entity.</span></code><code class="sig-name descname"><span class="pre">simplify_pos</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/named_entity.html#simplify_pos"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.named_entity.simplify_pos" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-nltk.chunk.regexp">
<span id="nltk-chunk-regexp-module"></span><h2>nltk.chunk.regexp module<a class="headerlink" href="#module-nltk.chunk.regexp" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="nltk.chunk.regexp.ChunkRule">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">nltk.chunk.regexp.</span></code><code class="sig-name descname"><span class="pre">ChunkRule</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tag_pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descr</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#ChunkRule"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.regexp.ChunkRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.regexp.RegexpChunkRule" title="nltk.chunk.regexp.RegexpChunkRule"><code class="xref py py-class docutils literal notranslate"><span class="pre">nltk.chunk.regexp.RegexpChunkRule</span></code></a></p>
<p>A rule specifying how to add chunks to a <code class="docutils literal notranslate"><span class="pre">ChunkString</span></code>, using a
matching tag pattern.  When applied to a <code class="docutils literal notranslate"><span class="pre">ChunkString</span></code>, it will
find any substring that matches this tag pattern and that is not
already part of a chunk, and create a new chunk containing that
substring.</p>
</dd></dl>

<dl class="py class">
<dt id="nltk.chunk.regexp.ChunkRuleWithContext">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">nltk.chunk.regexp.</span></code><code class="sig-name descname"><span class="pre">ChunkRuleWithContext</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">left_context_tag_pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chunk_tag_pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">right_context_tag_pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descr</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#ChunkRuleWithContext"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.regexp.ChunkRuleWithContext" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.regexp.RegexpChunkRule" title="nltk.chunk.regexp.RegexpChunkRule"><code class="xref py py-class docutils literal notranslate"><span class="pre">nltk.chunk.regexp.RegexpChunkRule</span></code></a></p>
<p>A rule specifying how to add chunks to a <code class="docutils literal notranslate"><span class="pre">ChunkString</span></code>, using
three matching tag patterns: one for the left context, one for the
chunk, and one for the right context.  When applied to a
<code class="docutils literal notranslate"><span class="pre">ChunkString</span></code>, it will find any substring that matches the chunk
tag pattern, is surrounded by substrings that match the two
context patterns, and is not already part of a chunk; and create a
new chunk containing the substring that matched the chunk tag
pattern.</p>
<p>Caveat: Both the left and right context are consumed when this
rule matches; therefore, if you need to find overlapping matches,
you will need to apply your rule more than once.</p>
</dd></dl>

<dl class="py class">
<dt id="nltk.chunk.regexp.ChunkString">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">nltk.chunk.regexp.</span></code><code class="sig-name descname"><span class="pre">ChunkString</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chunk_struct</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">debug_level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#ChunkString"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.regexp.ChunkString" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A string-based encoding of a particular chunking of a text.
Internally, the <code class="docutils literal notranslate"><span class="pre">ChunkString</span></code> class uses a single string to
encode the chunking of the input text.  This string contains a
sequence of angle-bracket delimited tags, with chunking indicated
by braces.  An example of this encoding is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="o">&lt;</span><span class="n">DT</span><span class="o">&gt;&lt;</span><span class="n">JJ</span><span class="o">&gt;&lt;</span><span class="n">NN</span><span class="o">&gt;</span><span class="p">}</span><span class="o">&lt;</span><span class="n">VBN</span><span class="o">&gt;&lt;</span><span class="n">IN</span><span class="o">&gt;</span><span class="p">{</span><span class="o">&lt;</span><span class="n">DT</span><span class="o">&gt;&lt;</span><span class="n">NN</span><span class="o">&gt;</span><span class="p">}</span><span class="o">&lt;.&gt;</span><span class="p">{</span><span class="o">&lt;</span><span class="n">DT</span><span class="o">&gt;&lt;</span><span class="n">NN</span><span class="o">&gt;</span><span class="p">}</span><span class="o">&lt;</span><span class="n">VBD</span><span class="o">&gt;&lt;.&gt;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">ChunkString</span></code> are created from tagged texts (i.e., lists of
<code class="docutils literal notranslate"><span class="pre">tokens</span></code> whose type is <code class="docutils literal notranslate"><span class="pre">TaggedType</span></code>).  Initially, nothing is
chunked.</p>
<p>The chunking of a <code class="docutils literal notranslate"><span class="pre">ChunkString</span></code> can be modified with the <code class="docutils literal notranslate"><span class="pre">xform()</span></code>
method, which uses a regular expression to transform the string
representation.  These transformations should only add and remove
braces; they should <em>not</em> modify the sequence of angle-bracket
delimited tags.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>_str</strong> – <p>The internal string representation of the text’s
encoding.  This string representation contains a sequence of
angle-bracket delimited tags, with chunking indicated by
braces.  An example of this encoding is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="o">&lt;</span><span class="n">DT</span><span class="o">&gt;&lt;</span><span class="n">JJ</span><span class="o">&gt;&lt;</span><span class="n">NN</span><span class="o">&gt;</span><span class="p">}</span><span class="o">&lt;</span><span class="n">VBN</span><span class="o">&gt;&lt;</span><span class="n">IN</span><span class="o">&gt;</span><span class="p">{</span><span class="o">&lt;</span><span class="n">DT</span><span class="o">&gt;&lt;</span><span class="n">NN</span><span class="o">&gt;</span><span class="p">}</span><span class="o">&lt;.&gt;</span><span class="p">{</span><span class="o">&lt;</span><span class="n">DT</span><span class="o">&gt;&lt;</span><span class="n">NN</span><span class="o">&gt;</span><span class="p">}</span><span class="o">&lt;</span><span class="n">VBD</span><span class="o">&gt;&lt;.&gt;</span>
</pre></div>
</div>
</p></li>
<li><p><strong>_pieces</strong> – The tagged tokens and chunks encoded by this <code class="docutils literal notranslate"><span class="pre">ChunkString</span></code>.</p></li>
<li><p><strong>_debug</strong> – The debug level.  See the constructor docs.</p></li>
<li><p><a class="reference internal" href="#nltk.chunk.regexp.ChunkString.IN_CHUNK_PATTERN" title="nltk.chunk.regexp.ChunkString.IN_CHUNK_PATTERN"><strong>IN_CHUNK_PATTERN</strong></a> – A zero-width regexp pattern string that
will only match positions that are in chunks.</p></li>
<li><p><a class="reference internal" href="#nltk.chunk.regexp.ChunkString.IN_STRIP_PATTERN" title="nltk.chunk.regexp.ChunkString.IN_STRIP_PATTERN"><strong>IN_STRIP_PATTERN</strong></a> – A zero-width regexp pattern string that
will only match positions that are in strips.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt id="nltk.chunk.regexp.ChunkString.CHUNK_TAG">
<code class="sig-name descname"><span class="pre">CHUNK_TAG</span></code><em class="property"> <span class="pre">=</span> <span class="pre">'(&lt;[^\\{\\}&lt;&gt;]+?&gt;)'</span></em><a class="headerlink" href="#nltk.chunk.regexp.ChunkString.CHUNK_TAG" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="nltk.chunk.regexp.ChunkString.CHUNK_TAG_CHAR">
<code class="sig-name descname"><span class="pre">CHUNK_TAG_CHAR</span></code><em class="property"> <span class="pre">=</span> <span class="pre">'[^\\{\\}&lt;&gt;]'</span></em><a class="headerlink" href="#nltk.chunk.regexp.ChunkString.CHUNK_TAG_CHAR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="nltk.chunk.regexp.ChunkString.IN_CHUNK_PATTERN">
<code class="sig-name descname"><span class="pre">IN_CHUNK_PATTERN</span></code><em class="property"> <span class="pre">=</span> <span class="pre">'(?=[^\\{]*\\})'</span></em><a class="headerlink" href="#nltk.chunk.regexp.ChunkString.IN_CHUNK_PATTERN" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt id="nltk.chunk.regexp.ChunkString.IN_STRIP_PATTERN">
<code class="sig-name descname"><span class="pre">IN_STRIP_PATTERN</span></code><em class="property"> <span class="pre">=</span> <span class="pre">'(?=[^\\}]*(\\{|$))'</span></em><a class="headerlink" href="#nltk.chunk.regexp.ChunkString.IN_STRIP_PATTERN" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="nltk.chunk.regexp.ChunkString.to_chunkstruct">
<code class="sig-name descname"><span class="pre">to_chunkstruct</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chunk_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'CHUNK'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#ChunkString.to_chunkstruct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.regexp.ChunkString.to_chunkstruct" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the chunk structure encoded by this <code class="docutils literal notranslate"><span class="pre">ChunkString</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="nltk.html#nltk.tree.Tree" title="nltk.tree.Tree">Tree</a></p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If a transformation has generated an
invalid chunkstring.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltk.chunk.regexp.ChunkString.xform">
<code class="sig-name descname"><span class="pre">xform</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">regexp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repl</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#ChunkString.xform"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.regexp.ChunkString.xform" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the given transformation to the string encoding of this
<code class="docutils literal notranslate"><span class="pre">ChunkString</span></code>.  In particular, find all occurrences that match
<code class="docutils literal notranslate"><span class="pre">regexp</span></code>, and replace them using <code class="docutils literal notranslate"><span class="pre">repl</span></code> (as done by
<code class="docutils literal notranslate"><span class="pre">re.sub</span></code>).</p>
<p>This transformation should only add and remove braces; it
should <em>not</em> modify the sequence of angle-bracket delimited
tags.  Furthermore, this transformation may not result in
improper bracketing.  Note, in particular, that bracketing may
not be nested.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>regexp</strong> (<em>str</em><em> or </em><em>regexp</em>) – A regular expression matching the substring
that should be replaced.  This will typically include a
named group, which can be used by <code class="docutils literal notranslate"><span class="pre">repl</span></code>.</p></li>
<li><p><strong>repl</strong> (<em>str</em>) – An expression specifying what should replace the
matched substring.  Typically, this will include a named
replacement group, specified by <code class="docutils literal notranslate"><span class="pre">regexp</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If this transformation generated an
invalid chunkstring.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nltk.chunk.regexp.ExpandLeftRule">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">nltk.chunk.regexp.</span></code><code class="sig-name descname"><span class="pre">ExpandLeftRule</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">left_tag_pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">right_tag_pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descr</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#ExpandLeftRule"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.regexp.ExpandLeftRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.regexp.RegexpChunkRule" title="nltk.chunk.regexp.RegexpChunkRule"><code class="xref py py-class docutils literal notranslate"><span class="pre">nltk.chunk.regexp.RegexpChunkRule</span></code></a></p>
<p>A rule specifying how to expand chunks in a <code class="docutils literal notranslate"><span class="pre">ChunkString</span></code> to the left,
using two matching tag patterns: a left pattern, and a right pattern.
When applied to a <code class="docutils literal notranslate"><span class="pre">ChunkString</span></code>, it will find any chunk whose beginning
matches right pattern, and immediately preceded by a strip whose
end matches left pattern.  It will then expand the chunk to incorporate
the new material on the left.</p>
</dd></dl>

<dl class="py class">
<dt id="nltk.chunk.regexp.ExpandRightRule">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">nltk.chunk.regexp.</span></code><code class="sig-name descname"><span class="pre">ExpandRightRule</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">left_tag_pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">right_tag_pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descr</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#ExpandRightRule"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.regexp.ExpandRightRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.regexp.RegexpChunkRule" title="nltk.chunk.regexp.RegexpChunkRule"><code class="xref py py-class docutils literal notranslate"><span class="pre">nltk.chunk.regexp.RegexpChunkRule</span></code></a></p>
<p>A rule specifying how to expand chunks in a <code class="docutils literal notranslate"><span class="pre">ChunkString</span></code> to the
right, using two matching tag patterns: a left pattern, and a
right pattern.  When applied to a <code class="docutils literal notranslate"><span class="pre">ChunkString</span></code>, it will find any
chunk whose end matches left pattern, and immediately followed by
a strip whose beginning matches right pattern.  It will then
expand the chunk to incorporate the new material on the right.</p>
</dd></dl>

<dl class="py class">
<dt id="nltk.chunk.regexp.MergeRule">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">nltk.chunk.regexp.</span></code><code class="sig-name descname"><span class="pre">MergeRule</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">left_tag_pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">right_tag_pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descr</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#MergeRule"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.regexp.MergeRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.regexp.RegexpChunkRule" title="nltk.chunk.regexp.RegexpChunkRule"><code class="xref py py-class docutils literal notranslate"><span class="pre">nltk.chunk.regexp.RegexpChunkRule</span></code></a></p>
<p>A rule specifying how to merge chunks in a <code class="docutils literal notranslate"><span class="pre">ChunkString</span></code>, using
two matching tag patterns: a left pattern, and a right pattern.
When applied to a <code class="docutils literal notranslate"><span class="pre">ChunkString</span></code>, it will find any chunk whose end
matches left pattern, and immediately followed by a chunk whose
beginning matches right pattern.  It will then merge those two
chunks into a single chunk.</p>
</dd></dl>

<dl class="py class">
<dt id="nltk.chunk.regexp.RegexpChunkParser">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">nltk.chunk.regexp.</span></code><code class="sig-name descname"><span class="pre">RegexpChunkParser</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rules</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chunk_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'NP'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">root_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'S'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#RegexpChunkParser"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.regexp.RegexpChunkParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.api.ChunkParserI" title="nltk.chunk.api.ChunkParserI"><code class="xref py py-class docutils literal notranslate"><span class="pre">nltk.chunk.api.ChunkParserI</span></code></a></p>
<p>A regular expression based chunk parser.  <code class="docutils literal notranslate"><span class="pre">RegexpChunkParser</span></code> uses a
sequence of “rules” to find chunks of a single type within a
text.  The chunking of the text is encoded using a <code class="docutils literal notranslate"><span class="pre">ChunkString</span></code>,
and each rule acts by modifying the chunking in the
<code class="docutils literal notranslate"><span class="pre">ChunkString</span></code>.  The rules are all implemented using regular
expression matching and substitution.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">RegexpChunkRule</span></code> class and its subclasses (<code class="docutils literal notranslate"><span class="pre">ChunkRule</span></code>,
<code class="docutils literal notranslate"><span class="pre">StripRule</span></code>, <code class="docutils literal notranslate"><span class="pre">UnChunkRule</span></code>, <code class="docutils literal notranslate"><span class="pre">MergeRule</span></code>, and <code class="docutils literal notranslate"><span class="pre">SplitRule</span></code>)
define the rules that are used by <code class="docutils literal notranslate"><span class="pre">RegexpChunkParser</span></code>.  Each rule
defines an <code class="docutils literal notranslate"><span class="pre">apply()</span></code> method, which modifies the chunking encoded
by a given <code class="docutils literal notranslate"><span class="pre">ChunkString</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>_rules</strong> – The list of rules that should be applied to a text.</p></li>
<li><p><strong>_trace</strong> – The default level of tracing.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="nltk.chunk.regexp.RegexpChunkParser.parse">
<code class="sig-name descname"><span class="pre">parse</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chunk_struct</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#RegexpChunkParser.parse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.regexp.RegexpChunkParser.parse" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>chunk_struct</strong> (<a class="reference internal" href="nltk.html#nltk.tree.Tree" title="nltk.tree.Tree"><em>Tree</em></a>) – the chunk structure to be (further) chunked</p></li>
<li><p><strong>trace</strong> (<em>int</em>) – The level of tracing that should be used when
parsing a text.  <code class="docutils literal notranslate"><span class="pre">0</span></code> will generate no tracing output;
<code class="docutils literal notranslate"><span class="pre">1</span></code> will generate normal tracing output; and <code class="docutils literal notranslate"><span class="pre">2</span></code> or
highter will generate verbose tracing output.  This value
overrides the trace level value that was given to the
constructor.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="nltk.html#nltk.tree.Tree" title="nltk.tree.Tree">Tree</a></p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a chunk structure that encodes the chunks in a given
tagged sentence.  A chunk is a non-overlapping linguistic
group, such as a noun phrase.  The set of chunks
identified in the chunk structure depends on the rules
used to define this <code class="docutils literal notranslate"><span class="pre">RegexpChunkParser</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltk.chunk.regexp.RegexpChunkParser.rules">
<code class="sig-name descname"><span class="pre">rules</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#RegexpChunkParser.rules"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.regexp.RegexpChunkParser.rules" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the sequence of rules used by <code class="docutils literal notranslate"><span class="pre">RegexpChunkParser</span></code>.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list(<a class="reference internal" href="#nltk.chunk.regexp.RegexpChunkRule" title="nltk.chunk.regexp.RegexpChunkRule">RegexpChunkRule</a>)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nltk.chunk.regexp.RegexpChunkRule">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">nltk.chunk.regexp.</span></code><code class="sig-name descname"><span class="pre">RegexpChunkRule</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">regexp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descr</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#RegexpChunkRule"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.regexp.RegexpChunkRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A rule specifying how to modify the chunking in a <code class="docutils literal notranslate"><span class="pre">ChunkString</span></code>,
using a transformational regular expression.  The
<code class="docutils literal notranslate"><span class="pre">RegexpChunkRule</span></code> class itself can be used to implement any
transformational rule based on regular expressions.  There are
also a number of subclasses, which can be used to implement
simpler types of rules, based on matching regular expressions.</p>
<p>Each <code class="docutils literal notranslate"><span class="pre">RegexpChunkRule</span></code> has a regular expression and a
replacement expression.  When a <code class="docutils literal notranslate"><span class="pre">RegexpChunkRule</span></code> is “applied”
to a <code class="docutils literal notranslate"><span class="pre">ChunkString</span></code>, it searches the <code class="docutils literal notranslate"><span class="pre">ChunkString</span></code> for any
substring that matches the regular expression, and replaces it
using the replacement expression.  This search/replace operation
has the same semantics as <code class="docutils literal notranslate"><span class="pre">re.sub</span></code>.</p>
<p>Each <code class="docutils literal notranslate"><span class="pre">RegexpChunkRule</span></code> also has a description string, which
gives a short (typically less than 75 characters) description of
the purpose of the rule.</p>
<p>This transformation defined by this <code class="docutils literal notranslate"><span class="pre">RegexpChunkRule</span></code> should
only add and remove braces; it should <em>not</em> modify the sequence
of angle-bracket delimited tags.  Furthermore, this transformation
may not result in nested or mismatched bracketing.</p>
<dl class="py method">
<dt id="nltk.chunk.regexp.RegexpChunkRule.apply">
<code class="sig-name descname"><span class="pre">apply</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chunkstr</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#RegexpChunkRule.apply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.regexp.RegexpChunkRule.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply this rule to the given <code class="docutils literal notranslate"><span class="pre">ChunkString</span></code>.  See the
class reference documentation for a description of what it
means to apply a rule.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>chunkstr</strong> (<a class="reference internal" href="#nltk.chunk.regexp.ChunkString" title="nltk.chunk.regexp.ChunkString"><em>ChunkString</em></a>) – The chunkstring to which this rule is applied.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If this transformation generated an
invalid chunkstring.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltk.chunk.regexp.RegexpChunkRule.descr">
<code class="sig-name descname"><span class="pre">descr</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#RegexpChunkRule.descr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.regexp.RegexpChunkRule.descr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a short description of the purpose and/or effect of
this rule.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltk.chunk.regexp.RegexpChunkRule.fromstring">
<em class="property"><span class="pre">static</span> </em><code class="sig-name descname"><span class="pre">fromstring</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#RegexpChunkRule.fromstring"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.regexp.RegexpChunkRule.fromstring" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a RegexpChunkRule from a string description.
Currently, the following formats are supported:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">regexp</span><span class="p">}</span>         <span class="c1"># chunk rule</span>
<span class="p">}</span><span class="n">regexp</span><span class="p">{</span>         <span class="c1"># strip rule</span>
<span class="n">regexp</span><span class="p">}{</span><span class="n">regexp</span>   <span class="c1"># split rule</span>
<span class="n">regexp</span><span class="p">{}</span><span class="n">regexp</span>   <span class="c1"># merge rule</span>
</pre></div>
</div>
<p>Where <code class="docutils literal notranslate"><span class="pre">regexp</span></code> is a regular expression for the rule.  Any
text following the comment marker (<code class="docutils literal notranslate"><span class="pre">#</span></code>) will be used as
the rule’s description:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nltk.chunk.regexp</span> <span class="kn">import</span> <span class="n">RegexpChunkRule</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">RegexpChunkRule</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="s1">&#39;{&lt;DT&gt;?&lt;NN.*&gt;+}&#39;</span><span class="p">)</span>
<span class="go">&lt;ChunkRule: &#39;&lt;DT&gt;?&lt;NN.*&gt;+&#39;&gt;</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nltk.chunk.regexp.RegexpParser">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">nltk.chunk.regexp.</span></code><code class="sig-name descname"><span class="pre">RegexpParser</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grammar</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">root_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'S'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#RegexpParser"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.regexp.RegexpParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.api.ChunkParserI" title="nltk.chunk.api.ChunkParserI"><code class="xref py py-class docutils literal notranslate"><span class="pre">nltk.chunk.api.ChunkParserI</span></code></a></p>
<p>A grammar based chunk parser.  <code class="docutils literal notranslate"><span class="pre">chunk.RegexpParser</span></code> uses a set of
regular expression patterns to specify the behavior of the parser.
The chunking of the text is encoded using a <code class="docutils literal notranslate"><span class="pre">ChunkString</span></code>, and
each rule acts by modifying the chunking in the <code class="docutils literal notranslate"><span class="pre">ChunkString</span></code>.
The rules are all implemented using regular expression matching
and substitution.</p>
<p>A grammar contains one or more clauses in the following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NP</span><span class="p">:</span>
  <span class="p">{</span><span class="o">&lt;</span><span class="n">DT</span><span class="o">|</span><span class="n">JJ</span><span class="o">&gt;</span><span class="p">}</span>          <span class="c1"># chunk determiners and adjectives</span>
  <span class="p">}</span><span class="o">&lt;</span><span class="p">[</span>\<span class="o">.</span><span class="n">VI</span><span class="p">]</span><span class="o">.*&gt;+</span><span class="p">{</span>      <span class="c1"># strip any tag beginning with V, I, or .</span>
  <span class="o">&lt;.*&gt;</span><span class="p">}{</span><span class="o">&lt;</span><span class="n">DT</span><span class="o">&gt;</span>         <span class="c1"># split a chunk at a determiner</span>
  <span class="o">&lt;</span><span class="n">DT</span><span class="o">|</span><span class="n">JJ</span><span class="o">&gt;</span><span class="p">{}</span><span class="o">&lt;</span><span class="n">NN</span><span class="o">.*&gt;</span>    <span class="c1"># merge chunk ending with det/adj</span>
                     <span class="c1"># with one starting with a noun</span>
</pre></div>
</div>
<p>The patterns of a clause are executed in order.  An earlier
pattern may introduce a chunk boundary that prevents a later
pattern from executing.  Sometimes an individual pattern will
match on multiple, overlapping extents of the input.  As with
regular expression substitution more generally, the chunker will
identify the first match possible, then continue looking for matches
after this one has ended.</p>
<p>The clauses of a grammar are also executed in order.  A cascaded
chunk parser is one having more than one clause.  The maximum depth
of a parse tree created by this chunk parser is the same as the
number of clauses in the grammar.</p>
<p>When tracing is turned on, the comment portion of a line is displayed
each time the corresponding pattern is applied.</p>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>_start</strong> – The start symbol of the grammar (the root node of
resulting trees)</p></li>
<li><p><strong>_stages</strong> – The list of parsing stages corresponding to the grammar</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="nltk.chunk.regexp.RegexpParser.parse">
<code class="sig-name descname"><span class="pre">parse</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chunk_struct</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#RegexpParser.parse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.regexp.RegexpParser.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the chunk parser to this input.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>chunk_struct</strong> (<a class="reference internal" href="nltk.html#nltk.tree.Tree" title="nltk.tree.Tree"><em>Tree</em></a>) – the chunk structure to be (further) chunked
(this tree is modified, and is also returned)</p></li>
<li><p><strong>trace</strong> (<em>int</em>) – The level of tracing that should be used when
parsing a text.  <code class="docutils literal notranslate"><span class="pre">0</span></code> will generate no tracing output;
<code class="docutils literal notranslate"><span class="pre">1</span></code> will generate normal tracing output; and <code class="docutils literal notranslate"><span class="pre">2</span></code> or
highter will generate verbose tracing output.  This value
overrides the trace level value that was given to the
constructor.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the chunked output.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="nltk.html#nltk.tree.Tree" title="nltk.tree.Tree">Tree</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="nltk.chunk.regexp.SplitRule">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">nltk.chunk.regexp.</span></code><code class="sig-name descname"><span class="pre">SplitRule</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">left_tag_pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">right_tag_pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descr</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#SplitRule"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.regexp.SplitRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.regexp.RegexpChunkRule" title="nltk.chunk.regexp.RegexpChunkRule"><code class="xref py py-class docutils literal notranslate"><span class="pre">nltk.chunk.regexp.RegexpChunkRule</span></code></a></p>
<p>A rule specifying how to split chunks in a <code class="docutils literal notranslate"><span class="pre">ChunkString</span></code>, using
two matching tag patterns: a left pattern, and a right pattern.
When applied to a <code class="docutils literal notranslate"><span class="pre">ChunkString</span></code>, it will find any chunk that
matches the left pattern followed by the right pattern.  It will
then split the chunk into two new chunks, at the point between the
two pattern matches.</p>
</dd></dl>

<dl class="py class">
<dt id="nltk.chunk.regexp.StripRule">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">nltk.chunk.regexp.</span></code><code class="sig-name descname"><span class="pre">StripRule</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tag_pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descr</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#StripRule"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.regexp.StripRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.regexp.RegexpChunkRule" title="nltk.chunk.regexp.RegexpChunkRule"><code class="xref py py-class docutils literal notranslate"><span class="pre">nltk.chunk.regexp.RegexpChunkRule</span></code></a></p>
<p>A rule specifying how to remove strips to a <code class="docutils literal notranslate"><span class="pre">ChunkString</span></code>,
using a matching tag pattern.  When applied to a
<code class="docutils literal notranslate"><span class="pre">ChunkString</span></code>, it will find any substring that matches this
tag pattern and that is contained in a chunk, and remove it
from that chunk, thus creating two new chunks.</p>
</dd></dl>

<dl class="py class">
<dt id="nltk.chunk.regexp.UnChunkRule">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">nltk.chunk.regexp.</span></code><code class="sig-name descname"><span class="pre">UnChunkRule</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tag_pattern</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">descr</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#UnChunkRule"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.regexp.UnChunkRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#nltk.chunk.regexp.RegexpChunkRule" title="nltk.chunk.regexp.RegexpChunkRule"><code class="xref py py-class docutils literal notranslate"><span class="pre">nltk.chunk.regexp.RegexpChunkRule</span></code></a></p>
<p>A rule specifying how to remove chunks to a <code class="docutils literal notranslate"><span class="pre">ChunkString</span></code>,
using a matching tag pattern.  When applied to a
<code class="docutils literal notranslate"><span class="pre">ChunkString</span></code>, it will find any complete chunk that matches this
tag pattern, and un-chunk it.</p>
</dd></dl>

<dl class="py function">
<dt id="nltk.chunk.regexp.demo">
<code class="sig-prename descclassname"><span class="pre">nltk.chunk.regexp.</span></code><code class="sig-name descname"><span class="pre">demo</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#demo"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.regexp.demo" title="Permalink to this definition">¶</a></dt>
<dd><p>A demonstration for the <code class="docutils literal notranslate"><span class="pre">RegexpChunkParser</span></code> class.  A single text is
parsed with four different chunk parsers, using a variety of rules
and strategies.</p>
</dd></dl>

<dl class="py function">
<dt id="nltk.chunk.regexp.demo_eval">
<code class="sig-prename descclassname"><span class="pre">nltk.chunk.regexp.</span></code><code class="sig-name descname"><span class="pre">demo_eval</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chunkparser</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">text</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#demo_eval"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.regexp.demo_eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Demonstration code for evaluating a chunk parser, using a
<code class="docutils literal notranslate"><span class="pre">ChunkScore</span></code>.  This function assumes that <code class="docutils literal notranslate"><span class="pre">text</span></code> contains one
sentence per line, and that each sentence has the form expected by
<code class="docutils literal notranslate"><span class="pre">tree.chunk</span></code>.  It runs the given chunk parser on each sentence in
the text, and scores the result.  It prints the final score
(precision, recall, and f-measure); and reports the set of chunks
that were missed and the set of chunks that were incorrect.  (At
most 10 missing chunks and 10 incorrect chunks are reported).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>chunkparser</strong> (<a class="reference internal" href="#nltk.chunk.api.ChunkParserI" title="nltk.chunk.api.ChunkParserI"><em>ChunkParserI</em></a>) – The chunkparser to be tested</p></li>
<li><p><strong>text</strong> (<em>str</em>) – The chunked tagged text that should be used for
evaluation.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltk.chunk.regexp.tag_pattern2re_pattern">
<code class="sig-prename descclassname"><span class="pre">nltk.chunk.regexp.</span></code><code class="sig-name descname"><span class="pre">tag_pattern2re_pattern</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tag_pattern</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/regexp.html#tag_pattern2re_pattern"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.regexp.tag_pattern2re_pattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a tag pattern to a regular expression pattern.  A “tag
pattern” is a modified version of a regular expression, designed
for matching sequences of tags.  The differences between regular
expression patterns and tag patterns are:</p>
<blockquote>
<div><ul class="simple">
<li><p>In tag patterns, <code class="docutils literal notranslate"><span class="pre">'&lt;'</span></code> and <code class="docutils literal notranslate"><span class="pre">'&gt;'</span></code> act as parentheses; so
<code class="docutils literal notranslate"><span class="pre">'&lt;NN&gt;+'</span></code> matches one or more repetitions of <code class="docutils literal notranslate"><span class="pre">'&lt;NN&gt;'</span></code>, not
<code class="docutils literal notranslate"><span class="pre">'&lt;NN'</span></code> followed by one or more repetitions of <code class="docutils literal notranslate"><span class="pre">'&gt;'</span></code>.</p></li>
<li><p>Whitespace in tag patterns is ignored.  So
<code class="docutils literal notranslate"><span class="pre">'&lt;DT&gt;</span> <span class="pre">|</span> <span class="pre">&lt;NN&gt;'</span></code> is equivalant to <code class="docutils literal notranslate"><span class="pre">'&lt;DT&gt;|&lt;NN&gt;'</span></code></p></li>
<li><p>In tag patterns, <code class="docutils literal notranslate"><span class="pre">'.'</span></code> is equivalant to <code class="docutils literal notranslate"><span class="pre">'[^{}&lt;&gt;]'</span></code>; so
<code class="docutils literal notranslate"><span class="pre">'&lt;NN.*&gt;'</span></code> matches any single tag starting with <code class="docutils literal notranslate"><span class="pre">'NN'</span></code>.</p></li>
</ul>
</div></blockquote>
<p>In particular, <code class="docutils literal notranslate"><span class="pre">tag_pattern2re_pattern</span></code> performs the following
transformations on the given pattern:</p>
<blockquote>
<div><ul class="simple">
<li><p>Replace ‘.’ with ‘[^&lt;&gt;{}]’</p></li>
<li><p>Remove any whitespace</p></li>
<li><p>Add extra parens around ‘&lt;’ and ‘&gt;’, to make ‘&lt;’ and ‘&gt;’ act
like parentheses.  E.g., so that in ‘&lt;NN&gt;+’, the ‘+’ has scope
over the entire ‘&lt;NN&gt;’; and so that in ‘&lt;NN|IN&gt;’, the ‘|’ has
scope over ‘NN’ and ‘IN’, but not ‘&lt;’ or ‘&gt;’.</p></li>
<li><p>Check to make sure the resulting pattern is valid.</p></li>
</ul>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>tag_pattern</strong> (<em>str</em>) – The tag pattern to convert to a regular
expression pattern.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – If <code class="docutils literal notranslate"><span class="pre">tag_pattern</span></code> is not a valid tag pattern.
In particular, <code class="docutils literal notranslate"><span class="pre">tag_pattern</span></code> should not include braces; and it
should not contain nested or mismatched angle-brackets.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>str</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A regular expression pattern corresponding to
<code class="docutils literal notranslate"><span class="pre">tag_pattern</span></code>.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-nltk.chunk.util">
<span id="nltk-chunk-util-module"></span><h2>nltk.chunk.util module<a class="headerlink" href="#module-nltk.chunk.util" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="nltk.chunk.util.ChunkScore">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">nltk.chunk.util.</span></code><code class="sig-name descname"><span class="pre">ChunkScore</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/util.html#ChunkScore"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.util.ChunkScore" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A utility class for scoring chunk parsers.  <code class="docutils literal notranslate"><span class="pre">ChunkScore</span></code> can
evaluate a chunk parser’s output, based on a number of statistics
(precision, recall, f-measure, misssed chunks, incorrect chunks).
It can also combine the scores from the parsing of multiple texts;
this makes it significantly easier to evaluate a chunk parser that
operates one sentence at a time.</p>
<p>Texts are evaluated with the <code class="docutils literal notranslate"><span class="pre">score</span></code> method.  The results of
evaluation can be accessed via a number of accessor methods, such
as <code class="docutils literal notranslate"><span class="pre">precision</span></code> and <code class="docutils literal notranslate"><span class="pre">f_measure</span></code>.  A typical use of the
<code class="docutils literal notranslate"><span class="pre">ChunkScore</span></code> class is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">chunkscore</span> <span class="o">=</span> <span class="n">ChunkScore</span><span class="p">()</span>           
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">correct</span> <span class="ow">in</span> <span class="n">correct_sentences</span><span class="p">:</span>   
<span class="gp">... </span>    <span class="n">guess</span> <span class="o">=</span> <span class="n">chunkparser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">correct</span><span class="o">.</span><span class="n">leaves</span><span class="p">())</span>   
<span class="gp">... </span>    <span class="n">chunkscore</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">correct</span><span class="p">,</span> <span class="n">guess</span><span class="p">)</span>              
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;F Measure:&#39;</span><span class="p">,</span> <span class="n">chunkscore</span><span class="o">.</span><span class="n">f_measure</span><span class="p">())</span>       
<span class="go">F Measure: 0.823</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Variables</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>kwargs</strong> – <p>Keyword arguments:</p>
<ul>
<li><p>max_tp_examples: The maximum number actual examples of true
positives to record.  This affects the <code class="docutils literal notranslate"><span class="pre">correct</span></code> member
function: <code class="docutils literal notranslate"><span class="pre">correct</span></code> will not return more than this number
of true positive examples.  This does <em>not</em> affect any of
the numerical metrics (precision, recall, or f-measure)</p></li>
<li><p>max_fp_examples: The maximum number actual examples of false
positives to record.  This affects the <code class="docutils literal notranslate"><span class="pre">incorrect</span></code> member
function and the <code class="docutils literal notranslate"><span class="pre">guessed</span></code> member function: <code class="docutils literal notranslate"><span class="pre">incorrect</span></code>
will not return more than this number of examples, and
<code class="docutils literal notranslate"><span class="pre">guessed</span></code> will not return more than this number of true
positive examples.  This does <em>not</em> affect any of the
numerical metrics (precision, recall, or f-measure)</p></li>
<li><p>max_fn_examples: The maximum number actual examples of false
negatives to record.  This affects the <code class="docutils literal notranslate"><span class="pre">missed</span></code> member
function and the <code class="docutils literal notranslate"><span class="pre">correct</span></code> member function: <code class="docutils literal notranslate"><span class="pre">missed</span></code>
will not return more than this number of examples, and
<code class="docutils literal notranslate"><span class="pre">correct</span></code> will not return more than this number of true
negative examples.  This does <em>not</em> affect any of the
numerical metrics (precision, recall, or f-measure)</p></li>
<li><p>chunk_label: A regular expression indicating which chunks
should be compared.  Defaults to <code class="docutils literal notranslate"><span class="pre">'.*'</span></code> (i.e., all chunks).</p></li>
</ul>
</p></li>
<li><p><strong>_tp</strong> – List of true positives</p></li>
<li><p><strong>_fp</strong> – List of false positives</p></li>
<li><p><strong>_fn</strong> – List of false negatives</p></li>
<li><p><strong>_tp_num</strong> – Number of true positives</p></li>
<li><p><strong>_fp_num</strong> – Number of false positives</p></li>
<li><p><strong>_fn_num</strong> – Number of false negatives.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="nltk.chunk.util.ChunkScore.accuracy">
<code class="sig-name descname"><span class="pre">accuracy</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/util.html#ChunkScore.accuracy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.util.ChunkScore.accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the overall tag-based accuracy for all text that have
been scored by this <code class="docutils literal notranslate"><span class="pre">ChunkScore</span></code>, using the IOB (conll2000)
tag encoding.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltk.chunk.util.ChunkScore.correct">
<code class="sig-name descname"><span class="pre">correct</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/util.html#ChunkScore.correct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.util.ChunkScore.correct" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the chunks which were included in the correct
chunk structures, listed in input order.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of chunks</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltk.chunk.util.ChunkScore.f_measure">
<code class="sig-name descname"><span class="pre">f_measure</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/util.html#ChunkScore.f_measure"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.util.ChunkScore.f_measure" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the overall F measure for all texts that have been
scored by this <code class="docutils literal notranslate"><span class="pre">ChunkScore</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>alpha</strong> (<em>float</em>) – the relative weighting of precision and recall.
Larger alpha biases the score towards the precision value,
while smaller alpha biases the score towards the recall
value.  <code class="docutils literal notranslate"><span class="pre">alpha</span></code> should have a value in the range [0,1].</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltk.chunk.util.ChunkScore.guessed">
<code class="sig-name descname"><span class="pre">guessed</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/util.html#ChunkScore.guessed"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.util.ChunkScore.guessed" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the chunks which were included in the guessed
chunk structures, listed in input order.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of chunks</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltk.chunk.util.ChunkScore.incorrect">
<code class="sig-name descname"><span class="pre">incorrect</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/util.html#ChunkScore.incorrect"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.util.ChunkScore.incorrect" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the chunks which were included in the guessed chunk structures,
but not in the correct chunk structures, listed in input order.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of chunks</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltk.chunk.util.ChunkScore.missed">
<code class="sig-name descname"><span class="pre">missed</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/util.html#ChunkScore.missed"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.util.ChunkScore.missed" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the chunks which were included in the
correct chunk structures, but not in the guessed chunk
structures, listed in input order.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of chunks</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltk.chunk.util.ChunkScore.precision">
<code class="sig-name descname"><span class="pre">precision</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/util.html#ChunkScore.precision"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.util.ChunkScore.precision" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the overall precision for all texts that have been
scored by this <code class="docutils literal notranslate"><span class="pre">ChunkScore</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltk.chunk.util.ChunkScore.recall">
<code class="sig-name descname"><span class="pre">recall</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/util.html#ChunkScore.recall"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.util.ChunkScore.recall" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the overall recall for all texts that have been
scored by this <code class="docutils literal notranslate"><span class="pre">ChunkScore</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="nltk.chunk.util.ChunkScore.score">
<code class="sig-name descname"><span class="pre">score</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">correct</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">guessed</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/util.html#ChunkScore.score"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.util.ChunkScore.score" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a correctly chunked sentence, score another chunked
version of the same sentence.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>correct</strong> (<em>chunk structure</em>) – The known-correct (“gold standard”) chunked
sentence.</p></li>
<li><p><strong>guessed</strong> (<em>chunk structure</em>) – The chunked sentence to be scored.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="nltk.chunk.util.accuracy">
<code class="sig-prename descclassname"><span class="pre">nltk.chunk.util.</span></code><code class="sig-name descname"><span class="pre">accuracy</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chunker</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gold</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/util.html#accuracy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.util.accuracy" title="Permalink to this definition">¶</a></dt>
<dd><p>Score the accuracy of the chunker against the gold standard.
Strip the chunk information from the gold standard and rechunk it using
the chunker, then compute the accuracy score.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>chunker</strong> (<a class="reference internal" href="#nltk.chunk.api.ChunkParserI" title="nltk.chunk.api.ChunkParserI"><em>ChunkParserI</em></a>) – The chunker being evaluated.</p></li>
<li><p><strong>gold</strong> (<em>tree</em>) – The chunk structures to score the chunker on.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltk.chunk.util.conllstr2tree">
<code class="sig-prename descclassname"><span class="pre">nltk.chunk.util.</span></code><code class="sig-name descname"><span class="pre">conllstr2tree</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chunk_types</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">('NP',</span> <span class="pre">'PP',</span> <span class="pre">'VP')</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">root_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'S'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/util.html#conllstr2tree"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.util.conllstr2tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a chunk structure for a single sentence
encoded in the given CONLL 2000 style string.
This function converts a CoNLL IOB string into a tree.
It uses the specified chunk types
(defaults to NP, PP and VP), and creates a tree rooted at a node
labeled S (by default).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>s</strong> (<em>str</em>) – The CoNLL string to be converted.</p></li>
<li><p><strong>chunk_types</strong> (<em>tuple</em>) – The chunk types to be converted.</p></li>
<li><p><strong>root_label</strong> (<em>str</em>) – The node label to use for the root.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="nltk.html#nltk.tree.Tree" title="nltk.tree.Tree">Tree</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltk.chunk.util.conlltags2tree">
<code class="sig-prename descclassname"><span class="pre">nltk.chunk.util.</span></code><code class="sig-name descname"><span class="pre">conlltags2tree</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sentence</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chunk_types</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">('NP',</span> <span class="pre">'PP',</span> <span class="pre">'VP')</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">root_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'S'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strict</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/util.html#conlltags2tree"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.util.conlltags2tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the CoNLL IOB format to a tree.</p>
</dd></dl>

<dl class="py function">
<dt id="nltk.chunk.util.demo">
<code class="sig-prename descclassname"><span class="pre">nltk.chunk.util.</span></code><code class="sig-name descname"><span class="pre">demo</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/util.html#demo"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.util.demo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="nltk.chunk.util.ieerstr2tree">
<code class="sig-prename descclassname"><span class="pre">nltk.chunk.util.</span></code><code class="sig-name descname"><span class="pre">ieerstr2tree</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chunk_types</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['LOCATION',</span> <span class="pre">'ORGANIZATION',</span> <span class="pre">'PERSON',</span> <span class="pre">'DURATION',</span> <span class="pre">'DATE',</span> <span class="pre">'CARDINAL',</span> <span class="pre">'PERCENT',</span> <span class="pre">'MONEY',</span> <span class="pre">'MEASURE']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">root_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'S'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/util.html#ieerstr2tree"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.util.ieerstr2tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a chunk structure containing the chunked tagged text that is
encoded in the given IEER style string.
Convert a string of chunked tagged text in the IEER named
entity format into a chunk structure.  Chunks are of several
types, LOCATION, ORGANIZATION, PERSON, DURATION, DATE, CARDINAL,
PERCENT, MONEY, and MEASURE.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="nltk.html#nltk.tree.Tree" title="nltk.tree.Tree">Tree</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltk.chunk.util.tagstr2tree">
<code class="sig-prename descclassname"><span class="pre">nltk.chunk.util.</span></code><code class="sig-name descname"><span class="pre">tagstr2tree</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">chunk_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'NP'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">root_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'S'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'/'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source_tagset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_tagset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/util.html#tagstr2tree"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.util.tagstr2tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Divide a string of bracketted tagged text into
chunks and unchunked tokens, and produce a Tree.
Chunks are marked by square brackets (<code class="docutils literal notranslate"><span class="pre">[...]</span></code>).  Words are
delimited by whitespace, and each word should have the form
<code class="docutils literal notranslate"><span class="pre">text/tag</span></code>.  Words that do not contain a slash are
assigned a <code class="docutils literal notranslate"><span class="pre">tag</span></code> of None.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>s</strong> (<em>str</em>) – The string to be converted</p></li>
<li><p><strong>chunk_label</strong> (<em>str</em>) – The label to use for chunk nodes</p></li>
<li><p><strong>root_label</strong> (<em>str</em>) – The label to use for the root of the tree</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="nltk.html#nltk.tree.Tree" title="nltk.tree.Tree">Tree</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltk.chunk.util.tree2conllstr">
<code class="sig-prename descclassname"><span class="pre">nltk.chunk.util.</span></code><code class="sig-name descname"><span class="pre">tree2conllstr</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/util.html#tree2conllstr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.util.tree2conllstr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a multiline string where each line contains a word, tag and IOB tag.
Convert a tree to the CoNLL IOB string format</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>t</strong> (<a class="reference internal" href="nltk.html#nltk.tree.Tree" title="nltk.tree.Tree"><em>Tree</em></a>) – The tree to be converted.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="nltk.chunk.util.tree2conlltags">
<code class="sig-prename descclassname"><span class="pre">nltk.chunk.util.</span></code><code class="sig-name descname"><span class="pre">tree2conlltags</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk/util.html#tree2conlltags"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.util.tree2conlltags" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of 3-tuples containing <code class="docutils literal notranslate"><span class="pre">(word,</span> <span class="pre">tag,</span> <span class="pre">IOB-tag)</span></code>.
Convert a tree to the CoNLL IOB tag format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>t</strong> (<a class="reference internal" href="nltk.html#nltk.tree.Tree" title="nltk.tree.Tree"><em>Tree</em></a>) – The tree to be converted.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list(tuple)</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-nltk.chunk">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-nltk.chunk" title="Permalink to this headline">¶</a></h2>
<p>Classes and interfaces for identifying non-overlapping linguistic
groups (such as base noun phrases) in unrestricted text.  This task is
called “chunk parsing” or “chunking”, and the identified groups are
called “chunks”.  The chunked text is represented using a shallow
tree called a “chunk structure.”  A chunk structure is a tree
containing tokens and chunks, where each chunk is a subtree containing
only tokens.  For example, the chunk structure for base noun phrase
chunks in the sentence “I saw the big dog on the hill” is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">SENTENCE</span><span class="p">:</span>
  <span class="p">(</span><span class="n">NP</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">)</span>
  <span class="o">&lt;</span><span class="n">saw</span><span class="o">&gt;</span>
  <span class="p">(</span><span class="n">NP</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">the</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">big</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">dog</span><span class="o">&gt;</span><span class="p">)</span>
  <span class="o">&lt;</span><span class="n">on</span><span class="o">&gt;</span>
  <span class="p">(</span><span class="n">NP</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">the</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">hill</span><span class="o">&gt;</span><span class="p">))</span>
</pre></div>
</div>
<p>To convert a chunk structure back to a list of tokens, simply use the
chunk structure’s <code class="docutils literal notranslate"><span class="pre">leaves()</span></code> method.</p>
<p>This module defines <code class="docutils literal notranslate"><span class="pre">ChunkParserI</span></code>, a standard interface for
chunking texts; and <code class="docutils literal notranslate"><span class="pre">RegexpChunkParser</span></code>, a regular-expression based
implementation of that interface. It also defines <code class="docutils literal notranslate"><span class="pre">ChunkScore</span></code>, a
utility class for scoring chunk parsers.</p>
<div class="section" id="regexpchunkparser">
<h3>RegexpChunkParser<a class="headerlink" href="#regexpchunkparser" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">RegexpChunkParser</span></code> is an implementation of the chunk parser interface
that uses regular-expressions over tags to chunk a text.  Its
<code class="docutils literal notranslate"><span class="pre">parse()</span></code> method first constructs a <code class="docutils literal notranslate"><span class="pre">ChunkString</span></code>, which encodes a
particular chunking of the input text.  Initially, nothing is
chunked.  <code class="docutils literal notranslate"><span class="pre">parse.RegexpChunkParser</span></code> then applies a sequence of
<code class="docutils literal notranslate"><span class="pre">RegexpChunkRule</span></code> rules to the <code class="docutils literal notranslate"><span class="pre">ChunkString</span></code>, each of which modifies
the chunking that it encodes.  Finally, the <code class="docutils literal notranslate"><span class="pre">ChunkString</span></code> is
transformed back into a chunk structure, which is returned.</p>
<p><code class="docutils literal notranslate"><span class="pre">RegexpChunkParser</span></code> can only be used to chunk a single kind of phrase.
For example, you can use an <code class="docutils literal notranslate"><span class="pre">RegexpChunkParser</span></code> to chunk the noun
phrases in a text, or the verb phrases in a text; but you can not
use it to simultaneously chunk both noun phrases and verb phrases in
the same text.  (This is a limitation of <code class="docutils literal notranslate"><span class="pre">RegexpChunkParser</span></code>, not of
chunk parsers in general.)</p>
<div class="section" id="regexpchunkrules">
<h4>RegexpChunkRules<a class="headerlink" href="#regexpchunkrules" title="Permalink to this headline">¶</a></h4>
<p>A <code class="docutils literal notranslate"><span class="pre">RegexpChunkRule</span></code> is a transformational rule that updates the
chunking of a text by modifying its <code class="docutils literal notranslate"><span class="pre">ChunkString</span></code>.  Each
<code class="docutils literal notranslate"><span class="pre">RegexpChunkRule</span></code> defines the <code class="docutils literal notranslate"><span class="pre">apply()</span></code> method, which modifies
the chunking encoded by a <code class="docutils literal notranslate"><span class="pre">ChunkString</span></code>.  The
<code class="docutils literal notranslate"><span class="pre">RegexpChunkRule</span></code> class itself can be used to implement any
transformational rule based on regular expressions.  There are
also a number of subclasses, which can be used to implement
simpler types of rules:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ChunkRule</span></code> chunks anything that matches a given regular
expression.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">StripRule</span></code> strips anything that matches a given regular
expression.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">UnChunkRule</span></code> will un-chunk any chunk that matches a given
regular expression.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MergeRule</span></code> can be used to merge two contiguous chunks.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SplitRule</span></code> can be used to split a single chunk into two
smaller chunks.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ExpandLeftRule</span></code> will expand a chunk to incorporate new
unchunked material on the left.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ExpandRightRule</span></code> will expand a chunk to incorporate new
unchunked material on the right.</p></li>
</ul>
</div></blockquote>
<div class="section" id="tag-patterns">
<h5>Tag Patterns<a class="headerlink" href="#tag-patterns" title="Permalink to this headline">¶</a></h5>
<p>A <code class="docutils literal notranslate"><span class="pre">RegexpChunkRule</span></code> uses a modified version of regular
expression patterns, called “tag patterns”.  Tag patterns are
used to match sequences of tags.  Examples of tag patterns are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="sa">r</span><span class="s1">&#39;(&lt;DT&gt;|&lt;JJ&gt;|&lt;NN&gt;)+&#39;</span>
<span class="sa">r</span><span class="s1">&#39;&lt;NN&gt;+&#39;</span>
<span class="sa">r</span><span class="s1">&#39;&lt;NN.*&gt;&#39;</span>
</pre></div>
</div>
<p>The differences between regular expression patterns and tag
patterns are:</p>
<blockquote>
<div><ul class="simple">
<li><p>In tag patterns, <code class="docutils literal notranslate"><span class="pre">'&lt;'</span></code> and <code class="docutils literal notranslate"><span class="pre">'&gt;'</span></code> act as parentheses; so
<code class="docutils literal notranslate"><span class="pre">'&lt;NN&gt;+'</span></code> matches one or more repetitions of <code class="docutils literal notranslate"><span class="pre">'&lt;NN&gt;'</span></code>, not
<code class="docutils literal notranslate"><span class="pre">'&lt;NN'</span></code> followed by one or more repetitions of <code class="docutils literal notranslate"><span class="pre">'&gt;'</span></code>.</p></li>
<li><p>Whitespace in tag patterns is ignored.  So
<code class="docutils literal notranslate"><span class="pre">'&lt;DT&gt;</span> <span class="pre">|</span> <span class="pre">&lt;NN&gt;'</span></code> is equivalant to <code class="docutils literal notranslate"><span class="pre">'&lt;DT&gt;|&lt;NN&gt;'</span></code></p></li>
<li><p>In tag patterns, <code class="docutils literal notranslate"><span class="pre">'.'</span></code> is equivalant to <code class="docutils literal notranslate"><span class="pre">'[^{}&lt;&gt;]'</span></code>; so
<code class="docutils literal notranslate"><span class="pre">'&lt;NN.*&gt;'</span></code> matches any single tag starting with <code class="docutils literal notranslate"><span class="pre">'NN'</span></code>.</p></li>
</ul>
</div></blockquote>
<p>The function <code class="docutils literal notranslate"><span class="pre">tag_pattern2re_pattern</span></code> can be used to transform
a tag pattern to an equivalent regular expression pattern.</p>
</div>
</div>
<div class="section" id="efficiency">
<h4>Efficiency<a class="headerlink" href="#efficiency" title="Permalink to this headline">¶</a></h4>
<p>Preliminary tests indicate that <code class="docutils literal notranslate"><span class="pre">RegexpChunkParser</span></code> can chunk at a
rate of about 300 tokens/second, with a moderately complex rule set.</p>
<p>There may be problems if <code class="docutils literal notranslate"><span class="pre">RegexpChunkParser</span></code> is used with more than
5,000 tokens at a time.  In particular, evaluation of some regular
expressions may cause the Python regular expression engine to
exceed its maximum recursion depth.  We have attempted to minimize
these problems, but it is impossible to avoid them completely.  We
therefore recommend that you apply the chunk parser to a single
sentence at a time.</p>
</div>
<div class="section" id="emacs-tip">
<h4>Emacs Tip<a class="headerlink" href="#emacs-tip" title="Permalink to this headline">¶</a></h4>
<p>If you evaluate the following elisp expression in emacs, it will
colorize a <code class="docutils literal notranslate"><span class="pre">ChunkString</span></code> when you use an interactive python shell
with emacs or xemacs (“C-c !”):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">let</span> <span class="p">()</span>
  <span class="p">(</span><span class="n">defconst</span> <span class="n">comint</span><span class="o">-</span><span class="n">mode</span><span class="o">-</span><span class="n">font</span><span class="o">-</span><span class="n">lock</span><span class="o">-</span><span class="n">keywords</span>
    <span class="s1">&#39;((&quot;&lt;[^&gt;]+&gt;&quot; 0 &#39;</span><span class="n">font</span><span class="o">-</span><span class="n">lock</span><span class="o">-</span><span class="n">reference</span><span class="o">-</span><span class="n">face</span><span class="p">)</span>
      <span class="p">(</span><span class="s2">&quot;[</span><span class="si">{}</span><span class="s2">]&quot;</span> <span class="mi">0</span> <span class="s1">&#39;font-lock-function-name-face)))</span>
  <span class="p">(</span><span class="n">add</span><span class="o">-</span><span class="n">hook</span> <span class="s1">&#39;comint-mode-hook (lambda () (turn-on-font-lock))))</span>
</pre></div>
</div>
<p>You can evaluate this code by copying it to a temporary buffer,
placing the cursor after the last close parenthesis, and typing
“<code class="docutils literal notranslate"><span class="pre">C-x</span> <span class="pre">C-e</span></code>”.  You should evaluate it before running the interactive
session.  The change will last until you close emacs.</p>
</div>
<div class="section" id="unresolved-issues">
<h4>Unresolved Issues<a class="headerlink" href="#unresolved-issues" title="Permalink to this headline">¶</a></h4>
<p>If we use the <code class="docutils literal notranslate"><span class="pre">re</span></code> module for regular expressions, Python’s
regular expression engine generates “maximum recursion depth
exceeded” errors when processing very large texts, even for
regular expressions that should not require any recursion.  We
therefore use the <code class="docutils literal notranslate"><span class="pre">pre</span></code> module instead.  But note that <code class="docutils literal notranslate"><span class="pre">pre</span></code>
does not include Unicode support, so this module will not work
with unicode strings.  Note also that <code class="docutils literal notranslate"><span class="pre">pre</span></code> regular expressions
are not quite as advanced as <code class="docutils literal notranslate"><span class="pre">re</span></code> ones (e.g., no leftward
zero-length assertions).</p>
<dl class="field-list simple">
<dt class="field-odd">type CHUNK_TAG_PATTERN</dt>
<dd class="field-odd"><p>regexp</p>
</dd>
<dt class="field-even">var CHUNK_TAG_PATTERN</dt>
<dd class="field-even"><p>A regular expression to test whether a tag
pattern is valid.</p>
</dd>
</dl>
<dl class="py function">
<dt id="nltk.chunk.ne_chunk">
<code class="sig-prename descclassname"><span class="pre">nltk.chunk.</span></code><code class="sig-name descname"><span class="pre">ne_chunk</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tagged_tokens</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">binary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk.html#ne_chunk"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.ne_chunk" title="Permalink to this definition">¶</a></dt>
<dd><p>Use NLTK’s currently recommended named entity chunker to
chunk the given list of tagged tokens.</p>
</dd></dl>

<dl class="py function">
<dt id="nltk.chunk.ne_chunk_sents">
<code class="sig-prename descclassname"><span class="pre">nltk.chunk.</span></code><code class="sig-name descname"><span class="pre">ne_chunk_sents</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tagged_sentences</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">binary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/nltk/chunk.html#ne_chunk_sents"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#nltk.chunk.ne_chunk_sents" title="Permalink to this definition">¶</a></dt>
<dd><p>Use NLTK’s currently recommended named entity chunker to chunk the
given list of tagged sentences, each consisting of a list of tagged tokens.</p>
</dd></dl>

</div>
</div>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
        </div>
        <div class="sidebar">
          
          <h3>Table of Contents</h3>
          <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../news.html">NLTK News</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installing NLTK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../data.html">Installing NLTK Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contribute.html">Contribute to NLTK</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki/FAQ">FAQ</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/nltk/nltk/wiki">Wiki</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="nltk.html">API</a></li>
<li class="toctree-l1"><a class="reference external" href="http://www.nltk.org/howto">HOWTO</a></li>
</ul>

          <div role="search">
            <h3 style="margin-top: 1.5em;">Search</h3>
            <form class="search" action="../search.html" method="get">
                <input type="text" name="q" />
                <input type="submit" value="Go" />
            </form>
          </div>

        </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer-wrapper">
      <div class="footer">
        <div class="left">
          <div role="navigation" aria-label="related navigaton">
            <a href="nltk.chat.html" title="nltk.chat package"
              >previous</a> |
            <a href="nltk.classify.html" title="nltk.classify package"
              >next</a> |
            <a href="../py-modindex.html" title="Python Module Index"
              >modules</a> |
            <a href="../genindex.html" title="General Index"
              >index</a>
          </div>
          <div role="note" aria-label="source link">
              <br/>
              <a href="../_sources/api/nltk.chunk.rst.txt"
                rel="nofollow">Show Source</a>
          </div>
        </div>

        <div class="right">
          
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, NLTK Project.
      Last updated on Apr 07, 2021.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.5.2.
    </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

  </body>
</html>